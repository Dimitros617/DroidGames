@page "/referee/scoring"
@using BlazorApp1.Models
@using BlazorApp1.Services
@inject ITeamService TeamService
@inject IMapService MapService
@inject IScoreService ScoreService
@inject IScoreNotificationService ScoreNotificationService
@inject UserSession UserSession
@inject NavigationManager Navigation
@implements IDisposable

<PageTitle>Bodov√°n√≠ - Rozhodƒç√≠</PageTitle>

<BlazorApp1.Components.Shared.AuthGuard RequiredRoles="@(new[] { UserRole.Referee, UserRole.Admin })">
    <div class="referee-scoring-page">
        <div class="page-header">
            <h1>üéØ Bodov√°n√≠ t√Ωmu</h1>
            <p>Jednoduch√© bodov√°n√≠ - kliknƒõte na bloky v mapƒõ</p>
        </div>

        @if (!_isInitialized)
        {
            <div class="loading">
                <div class="spinner"></div>
                <p>Naƒç√≠t√°n√≠...</p>
            </div>
        }
        else
        {
            <!-- Sticky Team Indicator -->
            @if (!string.IsNullOrEmpty(_selectedTeamId))
            {
                <div class="sticky-team-indicator team-@GetTeamNumber() @(_isReadOnly ? "read-only" : "")">
                    <div class="indicator-content">
                        <span class="indicator-icon">@GetSelectedTeamIcon()</span>
                        <span class="indicator-text">
                            <strong>@GetSelectedTeamName()</strong>
                            @if (_isAwaitingApproval)
                            {
                                <small style="color: #f39c12;">‚è≥ ƒåek√° na schv√°len√≠</small>
                            }
                            else if (_wasRejected)
                            {
                                <small style="color: #e74c3c;">‚Ü©Ô∏è Vr√°ceno k opravƒõ</small>
                            }
                            else if (_isReadOnly)
                            {
                                <small style="color: #27ae60;">‚úÖ Schv√°leno</small>
                            }
                            else
                            {
                                <small>Aktu√°lnƒõ bodujete</small>
                            }
                        </span>
                        <span class="indicator-score">@_currentScore bod≈Ø</span>
                    </div>
                </div>
            }

            <!-- Team Selection -->
            <div class="team-selection">
                <h2>Vyberte t√Ωm</h2>
                <div class="team-buttons">
                    @if (_team1 != null)
                    {
                        <button class="team-card @(_selectedTeamId == _team1.Id ? "selected team-a" : "")"
                                @onclick="async () => await SelectTeam(_team1.Id)">
                            <span class="team-icon" style="background: #27ae60;">@_team1.Name[0]</span>
                            <div class="team-info">
                                <strong>@_team1.Name</strong>
                                <small>T√Ωm A</small>
                            </div>
                        </button>
                    }
                    
                    @if (_team2 != null)
                    {
                        <button class="team-card @(_selectedTeamId == _team2.Id ? "selected team-b" : "")"
                                @onclick="async () => await SelectTeam(_team2.Id)">
                            <span class="team-icon" style="background: #e74c3c;">@_team2.Name[0]</span>
                            <div class="team-info">
                                <strong>@_team2.Name</strong>
                                <small>T√Ωm B</small>
                            </div>
                        </button>
                    }
                </div>
            </div>

            @if (!string.IsNullOrEmpty(_selectedTeamId) && _selectedMap != null)
            {
                <!-- Map Grid -->
                <div class="map-section team-@GetTeamNumber()">
                    <h2>üó∫Ô∏è Hern√≠ pole</h2>
                    <div class="map-container">
                        <div class="map-grid">
                            @for (int y = 0; y < 6; y++)
                            {
                                var rowY = y; // Capture pro closure
                                @for (int x = 0; x < 9; x++)
                                {
                                    var colX = x; // Capture pro closure
                                    var block = GetBlockAt(colX, rowY);
                                    var eventIds = GetBlockEventIds(colX, rowY);
                                    var hasEvents = eventIds.Any();
                                    var isSelected = _selectedBlockX == colX && _selectedBlockY == rowY;
                                    var cssClasses = $"map-cell {GetBlockClass(block)} {(hasEvents ? "has-events" : "")} {(isSelected ? "selected-block" : "")}";
                                    var cellKey = $"cell-{colX}-{rowY}";
                                    
                                    <div @key="cellKey"
                                         class="@cssClasses"
                                         @onclick="() => OnBlockClick(block, colX, rowY)"
                                         title="[@colX,@rowY] Events: @eventIds.Count">
                                        
                                        @if (block != null)
                                        {
                                            <div class="block-icon">
                                                @GetBlockIcon(block.Type)
                                            </div>
                                            
                                            @if (hasEvents)
                                            {
                                                <div class="event-numbers">
                                                    @foreach (var eventId in eventIds)
                                                    {
                                                        <span class="event-num">@eventId</span>
                                                    }
                                                </div>
                                            }
                                        }
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>

                <!-- Events Table -->
                <div class="score-summary">
                    <h3>üìã Ud√°losti (po≈ôad√≠ kliknut√≠)</h3>
                    <div class="events-table">
                        @if (_scoringEvents.Any())
                        {
                            <table>
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Pozice</th>
                                        <th>Ud√°lost</th>
                                        <th>Body</th>
                                        <th></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var evt in _scoringEvents.OrderBy(e => e.Id))
                                    {
                                        <tr class="@(_selectedEventId == evt.Id ? "selected-event" : "")"
                                            @onclick="() => OnEventClick(evt)">
                                            <td class="event-id"><strong>@evt.Id</strong></td>
                                            <td class="event-pos">[@evt.X, @evt.Y]</td>
                                            <td class="event-desc">@evt.Description</td>
                                            <td class="event-points @(evt.Points > 0 ? "positive" : "negative")">
                                                @(evt.Points > 0 ? "+" : "")@evt.Points
                                            </td>
                                            <td class="event-actions">
                                                <button class="btn-remove" 
                                                        @onclick="async () => await ConfirmAndRemoveEvent(evt.Id)" 
                                                        @onclick:stopPropagation="true"
                                                        title="Smazat ud√°lost">
                                                    ‚ùå
                                                </button>
                                            </td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        }
                        else
                        {
                            <p class="no-events">Zat√≠m ≈æ√°dn√© ud√°losti. Kliknƒõte na bloky na mapƒõ.</p>
                        }
                    </div>
                </div>

                <div class="submit-section">
                    @if (_isAwaitingApproval)
                    {
                        <div class="status-badge awaiting">
                            <span class="badge-icon">‚è≥</span>
                            <span class="badge-text">ƒåek√° na schv√°len√≠ hlavn√≠m rozhodƒç√≠m</span>
                        </div>
                    }
                    else if (_wasRejected)
                    {
                        <div class="status-badge rejected">
                            <span class="badge-icon">‚Ü©Ô∏è</span>
                            <span class="badge-text">Vr√°ceno k opravƒõ - m≈Ø≈æete upravovat</span>
                        </div>
                        <button class="btn btn-primary btn-lg" 
                                @onclick="MarkAsCompleted"
                                disabled="@(_scoringEvents.Count == 0 || _isSubmitting)">
                            ‚úÖ Znovu odeslat k hodnocen√≠
                            @if (_isSubmitting)
                            {
                                <span class="spinner-small"></span>
                            }
                        </button>
                    }
                    else if (!_isReadOnly)
                    {
                        <button class="btn btn-primary btn-lg" 
                                @onclick="MarkAsCompleted"
                                disabled="@(_scoringEvents.Count == 0 || _isSubmitting)">
                            ‚úÖ Oznaƒçit jako dokonƒçen√©
                            @if (_isSubmitting)
                            {
                                <span class="spinner-small"></span>
                            }
                        </button>
                    }
                </div>
            }
            else
            {
                <div class="select-team-prompt">
                    <p>üëÜ Vyberte t√Ωm pro zaƒç√°tek bodov√°n√≠</p>
                </div>
            }
        }

        @if (!string.IsNullOrEmpty(_statusMessage))
        {
            <div class="toast @(_isError ? "error" : "success")">
                @_statusMessage
            </div>
        }
        
        @if (_showConfirmDialog)
        {
            <div class="confirm-overlay" @onclick="CancelConfirm">
                <div class="confirm-dialog" @onclick:stopPropagation="true">
                    <h3>‚ö†Ô∏è Potvrzen√≠</h3>
                    <p>@_confirmMessage</p>
                    <div class="confirm-actions">
                        <button class="btn-confirm-cancel" @onclick="CancelConfirm">Zru≈°it</button>
                        <button class="btn-confirm-ok" @onclick="ExecuteConfirm">@_confirmButtonText</button>
                    </div>
                </div>
            </div>
        }
    </div>
</BlazorApp1.Components.Shared.AuthGuard>

@code {
    private bool _isInitialized = false;
    private MapConfiguration? _selectedMap = null;
    private Team? _team1 = null;
    private Team? _team2 = null;
    private string _selectedTeamId = string.Empty;
    private RoundParticipation? _currentRound = null;
    
    private int _currentScore = 0;
    private List<ScoringEvent> _scoringEvents = new();
    private int _nextEventId = 1;
    private Dictionary<string, List<int>> _blockEventIds = new();
    
    private int _selectedBlockX = -1;
    private int _selectedBlockY = -1;
    private int _selectedEventId = -1;
    
    private bool _isSubmitting = false;
    private string _statusMessage = string.Empty;
    private bool _isError = false;
    private bool _isReadOnly = false; // Read-only kdy≈æ je hodnocen√≠ odesl√°no
    private bool _isAwaitingApproval = false; // ƒåek√° na schv√°len√≠
    private bool _wasRejected = false; // Bylo vr√°ceno
    
    private bool _showConfirmDialog = false;
    private string _confirmMessage = string.Empty;
    private string _confirmButtonText = "OK";
    private Action? _confirmAction = null;

    private class ScoringEvent
    {
        public int Id { get; set; }
        public int X { get; set; }
        public int Y { get; set; }
        public MapBlockType BlockType { get; set; }
        public string Description { get; set; } = string.Empty;
        public int Points { get; set; }
        public DateTime Timestamp { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
        
        // Subscribe to approval change events
        ScoreNotificationService.OnScoreApprovalChanged += HandleScoreApprovalChanged;
        
        _isInitialized = true;
    }
    
    private async Task HandleScoreApprovalChanged(string teamId, string refereeId)
    {
        var currentRefereeId = UserSession.UserId ?? "referee1";
        if (teamId == _selectedTeamId && refereeId == currentRefereeId)
        {
            Console.WriteLine($"[Referee] Score approval changed for my submission");
            
            await InvokeAsync(async () =>
            {
                // Nejd≈ô√≠v naƒç√≠st data
                await LoadTeamScoring();
                
                // Zjistit, jestli bylo schv√°leno nebo vr√°ceno
                var team = await TeamService.GetTeamByIdAsync(_selectedTeamId);
                if (team != null)
                {
                    var round = team.Rides.FirstOrDefault(r => r.RoundNumber == _currentRound?.RoundNumber);
                    if (round != null && round.RefereeScores.TryGetValue(refereeId, out var score))
                    {
                        if (score.IsApproved)
                        {
                            _statusMessage = "‚úÖ Va≈°e hodnocen√≠ bylo schv√°leno!";
                            _isError = false;
                        }
                        else if (score.IsRejected)
                        {
                            _statusMessage = $"‚Ü©Ô∏è Hodnocen√≠ vr√°ceno k opravƒõ: {score.RejectionReason}";
                            _isError = true;
                        }
                        
                        // Zobrazit toast na 5 sekund
                        StateHasChanged();
                        await Task.Delay(5000);
                        _statusMessage = string.Empty;
                        StateHasChanged();
                    }
                }
            });
        }
    }
    
    private async Task LoadData()
    {
        var teams = await TeamService.GetAllTeamsAsync();
        if (teams.Count >= 2)
        {
            _team1 = teams[0];
            _team2 = teams[1];
        }
        
        var maps = await MapService.GetAllMapsAsync();
        if (maps.Any())
        {
            _selectedMap = maps.FirstOrDefault(m => m.IsPublished);
        }
        
        _currentRound = new RoundParticipation
        {
            RoundNumber = 1,
            MapConfigurationId = _selectedMap?.Id ?? string.Empty
        };
    }

    private async Task SelectTeam(string teamId)
    {
        // Pokud je to stejn√Ω t√Ωm, nedƒõlat nic
        if (_selectedTeamId == teamId)
            return;
        
        // D≈ÆLE≈ΩIT√â: Ulo≈æit data STAR√âHO t√Ωmu P≈òED zmƒõnou _selectedTeamId!
        // Mus√≠me p≈ôedat star√© ID t√Ωmu do AutoSaveScore!
        if (!string.IsNullOrEmpty(_selectedTeamId) && _scoringEvents.Any())
        {
            var oldTeamId = _selectedTeamId; // Ulo≈æit star√© ID
            Console.WriteLine($"[SelectTeam] Saving team {oldTeamId} data before switching to {teamId}...");
            await AutoSaveScore(oldTeamId);
        }
        
        // Teprve teƒè zmƒõnit t√Ωm a naƒç√≠st jeho data
        Console.WriteLine($"[SelectTeam] Switching from {_selectedTeamId} to {teamId}");
        _selectedTeamId = teamId;
        await LoadTeamScoring();
    }
    
    private async Task LoadTeamScoring()
    {
        Console.WriteLine($"[LoadTeamScoring] START - Team: {_selectedTeamId}");
        
        ResetScoring();
        
        if (string.IsNullOrEmpty(_selectedTeamId) || _currentRound == null)
        {
            Console.WriteLine($"[LoadTeamScoring] EXIT - No team or round selected");
            return;
        }
            
        // Naƒç√≠st existuj√≠c√≠ hodnocen√≠
        var team = await TeamService.GetTeamByIdAsync(_selectedTeamId);
        if (team == null)
        {
            Console.WriteLine($"[LoadTeamScoring] EXIT - Team not found");
            return;
        }
        
        var round = team.Rides.FirstOrDefault(r => r.RoundNumber == _currentRound.RoundNumber);
        if (round == null)
        {
            Console.WriteLine($"[LoadTeamScoring] Round {_currentRound.RoundNumber} not found for team, creating new round");
            // Vytvo≈ô√≠me nov√© kolo pro t√Ωm
            round = new RoundParticipation
            {
                RoundNumber = _currentRound.RoundNumber,
                RefereeScores = new Dictionary<string, RefereeScore>()
            };
            team.Rides.Add(round);
            await TeamService.UpdateTeamAsync(team);
        }
        
        var refereeId = UserSession.UserId ?? "referee1";
        Console.WriteLine($"[LoadTeamScoring] Checking for referee {refereeId} scores in round {_currentRound.RoundNumber}");
        Console.WriteLine($"[LoadTeamScoring] Round has {round.RefereeScores.Count} referee scores");
        
        if (round.RefereeScores.TryGetValue(refereeId, out var existingScore))
        {
            Console.WriteLine($"[LoadTeamScoring] Found existing score! Events: {existingScore.Events.Count}, Score: {existingScore.TotalScore}");
            
            // Zkontrolovat stav hodnocen√≠
            _isAwaitingApproval = existingScore.IsSubmitted && !existingScore.IsApproved && !existingScore.IsRejected;
            _wasRejected = existingScore.IsRejected;
            _isReadOnly = existingScore.IsSubmitted && !existingScore.IsRejected; // Read-only pokud je odesl√°no a neni vr√°ceno
            
            Console.WriteLine($"[LoadTeamScoring] Status - IsSubmitted: {existingScore.IsSubmitted}, IsApproved: {existingScore.IsApproved}, IsRejected: {existingScore.IsRejected}");
            Console.WriteLine($"[LoadTeamScoring] Mode - ReadOnly: {_isReadOnly}, AwaitingApproval: {_isAwaitingApproval}, WasRejected: {_wasRejected}");
            
            // Obnovit ud√°losti z ulo≈æen√©ho hodnocen√≠
            _nextEventId = 1;
            foreach (var eventData in existingScore.Events.OrderBy(e => e.Timestamp))
            {
                Console.WriteLine($"[LoadTeamScoring] Restoring event #{eventData.Id}: {eventData.Description} at [{eventData.X},{eventData.Y}]");
                
                var scoringEvent = new ScoringEvent
                {
                    Id = eventData.Id,
                    X = eventData.X,
                    Y = eventData.Y,
                    BlockType = Enum.Parse<MapBlockType>(eventData.BlockType),
                    Description = eventData.Description,
                    Points = eventData.Points,
                    Timestamp = eventData.Timestamp
                };
                
                _scoringEvents.Add(scoringEvent);
                
                var key = $"{eventData.X},{eventData.Y}";
                if (!_blockEventIds.ContainsKey(key))
                    _blockEventIds[key] = new List<int>();
                _blockEventIds[key].Add(eventData.Id);
                
                if (eventData.Id >= _nextEventId)
                    _nextEventId = eventData.Id + 1;
            }
            
            _currentScore = existingScore.TotalScore;
            Console.WriteLine($"[LoadTeamScoring] COMPLETE - Restored {_scoringEvents.Count} events, score: {_currentScore}");
        }
        else
        {
            Console.WriteLine($"[LoadTeamScoring] No existing score found for this referee");
        }
        
        StateHasChanged();
    }
    
    private async Task ConfirmAndRemoveEvent(int eventId)
    {
        var evt = _scoringEvents.FirstOrDefault(e => e.Id == eventId);
        if (evt == null) return;
        
        _confirmMessage = $"Opravdu chcete smazat ud√°lost #{eventId} ({evt.Description})?";
        _confirmButtonText = "Smazat";
        _confirmAction = async () => await RemoveEvent(eventId);
        _showConfirmDialog = true;
        StateHasChanged();
        await Task.CompletedTask;
    }
    
    private void ExecuteConfirm()
    {
        _confirmAction?.Invoke();
        _showConfirmDialog = false;
        _confirmAction = null;
        StateHasChanged();
    }
    
    private void CancelConfirm()
    {
        _showConfirmDialog = false;
        _confirmAction = null;
        StateHasChanged();
    }
    
    private async Task AutoSaveScore(string? teamId = null)
    {
        // Pou≈æ√≠t p≈ôedan√Ω teamId nebo aktu√°ln√≠ _selectedTeamId
        var targetTeamId = teamId ?? _selectedTeamId;
        
        if (string.IsNullOrEmpty(targetTeamId) || _currentRound == null)
            return;
            
        try
        {
            // D≈ÆLE≈ΩIT√â: Zkontrolovat, zda nen√≠ sk√≥re u≈æ schv√°len√©
            var team = await TeamService.GetTeamByIdAsync(targetTeamId);
            if (team != null)
            {
                var round = team.Rides.FirstOrDefault(r => r.RoundNumber == _currentRound.RoundNumber);
                var refereeId = UserSession.UserId ?? "referee1";
                
                if (round?.RefereeScores.TryGetValue(refereeId, out var existingScore) == true)
                {
                    // Pokud je sk√≥re schv√°len√© nebo odesl√°no (ƒçek√° na schv√°len√≠), nesm√≠me ho p≈ôepsat
                    if (existingScore.IsApproved)
                    {
                        Console.WriteLine($"[AutoSave] SKIP - Score is already approved for team {targetTeamId}");
                        return;
                    }
                    
                    if (existingScore.IsSubmitted && !existingScore.IsRejected)
                    {
                        Console.WriteLine($"[AutoSave] SKIP - Score is submitted and awaiting approval for team {targetTeamId}");
                        return;
                    }
                }
            }
            
            Console.WriteLine($"[AutoSave] Saving score for team {targetTeamId}... (current selected: {_selectedTeamId})");
            
            // P≈ôev√©st ud√°losti na ScoringEventData
            var eventDataList = _scoringEvents.Select(e => new ScoringEventData
            {
                Id = e.Id,
                X = e.X,
                Y = e.Y,
                BlockType = e.BlockType.ToString(),
                Description = e.Description,
                Points = e.Points,
                Timestamp = e.Timestamp
            }).ToList();
            
            // Build breakdown from events
            var scoreBreakdown = new Dictionary<string, int>();
            var crystalTouches = _scoringEvents.Count(e => e.Description.Contains("Dotyk krystalu"));
            var validMoves = _scoringEvents.Count(e => e.Description.Contains("Validn√≠ p≈ôesun"));
            var sulfurHits = _scoringEvents.Count(e => e.Description.Contains("Naru≈°en√≠ s√≠ry"));
            
            if (crystalTouches > 0)
                scoreBreakdown[$"Dotyk krystal≈Ø ({crystalTouches}√ó)"] = crystalTouches;
            if (validMoves > 0)
                scoreBreakdown[$"Validn√≠ p≈ôesuny ({validMoves}√ó)"] = validMoves;
            if (sulfurHits > 0)
                scoreBreakdown[$"Naru≈°en√≠ s√≠ry ({sulfurHits}√ó)"] = -sulfurHits;
            
            var refereeScore = new RefereeScore
            {
                RefereeId = UserSession.UserId ?? "referee1",
                ScoreBreakdown = scoreBreakdown,
                TotalScore = _currentScore,
                SubmittedAt = DateTime.UtcNow,
                LastModifiedAt = DateTime.UtcNow,
                IsSubmitted = false,
                Events = eventDataList
            };
            
            await ScoreService.SubmitRefereeScoreAsync(
                targetTeamId,  // Pou≈æ√≠t targetTeamId m√≠sto _selectedTeamId!
                _currentRound.RoundNumber, 
                refereeScore
            );
            
            // Send SignalR notification via service
            await ScoreNotificationService.NotifyRefereeScoreUpdated(
                targetTeamId, 
                _currentRound.RoundNumber, 
                refereeScore.RefereeId);
            
            Console.WriteLine($"[AutoSave] Score saved successfully to team {targetTeamId}. Events: {eventDataList.Count}, Score: {_currentScore}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[AutoSave] Error: {ex.Message}");
        }
    }

    private void ResetScoring()
    {
        _scoringEvents.Clear();
        _blockEventIds.Clear();
        _nextEventId = 1;
        _currentScore = 0;
        _selectedBlockX = -1;
        _selectedBlockY = -1;
        _selectedEventId = -1;
    }
    
    private string GetTeamNumber()
    {
        if (_selectedTeamId == _team1?.Id) return "a";
        if (_selectedTeamId == _team2?.Id) return "b";
        return "";
    }
    
    private string GetSelectedTeamName()
    {
        if (_selectedTeamId == _team1?.Id) return _team1.Name;
        if (_selectedTeamId == _team2?.Id) return _team2.Name;
        return "";
    }
    
    private string GetSelectedTeamIcon()
    {
        if (_selectedTeamId == _team1?.Id) return _team1.Name[0].ToString();
        if (_selectedTeamId == _team2?.Id) return _team2.Name[0].ToString();
        return "";
    }

    private MapBlock? GetBlockAt(int x, int y)
    {
        return _selectedMap?.Blocks.FirstOrDefault(b => b.X == x && b.Y == y);
    }

    private List<int> GetBlockEventIds(int x, int y)
    {
        var key = $"{x},{y}";
        var result = _blockEventIds.GetValueOrDefault(key, new List<int>());
        //Console.WriteLine($"[GetBlockEventIds] [{x},{y}] key='{key}' -> {result.Count} events");
        return result;
    }

    private async Task OnBlockClick(MapBlock? block, int x, int y)
    {
        // Blokovat klik√°n√≠ v read-only re≈æimu
        if (_isReadOnly)
        {
            Console.WriteLine($"[OnBlockClick] BLOCKED - Read-only mode");
            _statusMessage = "‚ö†Ô∏è Hodnocen√≠ je ve stavu read-only. Nelze upravovat.";
            _isError = true;
            StateHasChanged();
            await Task.Delay(2000);
            _statusMessage = string.Empty;
            StateHasChanged();
            return;
        }
        
        if (block == null || string.IsNullOrEmpty(_selectedTeamId) || 
            block.Type == MapBlockType.Empty || block.Type == MapBlockType.Rock) 
            return;
        
        Console.WriteLine($"[OnBlockClick] Clicked on [{x},{y}] - Type: {block.Type}");
        
        // Zv√Ωraznit vybran√Ω blok
        _selectedBlockX = x;
        _selectedBlockY = y;
        _selectedEventId = -1;
        
        var key = $"{x},{y}";
        
        // P≈ôid√°n√≠ ud√°losti podle typu bloku
        if (block.Type == MapBlockType.BlueCrystal)
        {
            // Zjistit, zda u≈æ byl na t√©to sou≈ôadnici dotyk
            bool hadFirstTouch = _scoringEvents.Any(e => e.X == x && e.Y == y && e.Description.Contains("Dotyk krystalu"));
            
            if (!_blockEventIds.ContainsKey(key))
                _blockEventIds[key] = new List<int>();
            
            int pointsAdded = 0;
            
            // P≈ôidat dotyk pouze pokud je≈°tƒõ nebyl
            if (!hadFirstTouch)
            {
                var touchEvent = new ScoringEvent
                {
                    Id = _nextEventId++,
                    X = x,
                    Y = y,
                    BlockType = block.Type,
                    Description = "üíé Dotyk krystalu",
                    Points = 1,
                    Timestamp = DateTime.Now
                };
                
                _scoringEvents.Add(touchEvent);
                _blockEventIds[key].Add(touchEvent.Id);
                pointsAdded += 1;
                Console.WriteLine($"[OnBlockClick] Added touch event #{touchEvent.Id} at [{x},{y}]");
            }
            
            // V≈ædy p≈ôidat validn√≠ p≈ôesun
            var moveEvent = new ScoringEvent
            {
                Id = _nextEventId++,
                X = x,
                Y = y,
                BlockType = block.Type,
                Description = "üìè Validn√≠ p≈ôesun",
                Points = 1,
                Timestamp = DateTime.Now
            };
            
            _scoringEvents.Add(moveEvent);
            _blockEventIds[key].Add(moveEvent.Id);
            pointsAdded += 1;
            
            Console.WriteLine($"[OnBlockClick] Added move event #{moveEvent.Id} at [{x},{y}]");
            Console.WriteLine($"[OnBlockClick] Total events at [{x},{y}]: {_blockEventIds[key].Count}");
            
            _currentScore += pointsAdded;
        }
        else if (block.Type == MapBlockType.YellowSulfur)
        {
            var sulfurEvent = new ScoringEvent
            {
                Id = _nextEventId++,
                X = x,
                Y = y,
                BlockType = block.Type,
                Description = "üü° Naru≈°en√≠ s√≠ry",
                Points = -1,
                Timestamp = DateTime.Now
            };
            
            _scoringEvents.Add(sulfurEvent);
            
            if (!_blockEventIds.ContainsKey(key))
                _blockEventIds[key] = new List<int>();
            
            _blockEventIds[key].Add(sulfurEvent.Id);
            
            Console.WriteLine($"[OnBlockClick] Added sulfur event #{sulfurEvent.Id} at [{x},{y}]");
            Console.WriteLine($"[OnBlockClick] Total events at [{x},{y}]: {_blockEventIds[key].Count}");
            
            _currentScore -= 1;
        }
        
        Console.WriteLine($"[OnBlockClick] Total scoring events: {_scoringEvents.Count}");
        Console.WriteLine($"[OnBlockClick] BlockEventIds keys: {string.Join(", ", _blockEventIds.Keys)}");
        
        StateHasChanged();
        
        // Auto-save po ka≈æd√© zmƒõnƒõ
        await AutoSaveScore();
    }
    
    private void OnEventClick(ScoringEvent evt)
    {
        _selectedEventId = evt.Id;
        _selectedBlockX = evt.X;
        _selectedBlockY = evt.Y;
        StateHasChanged();
    }

    private async Task RemoveEvent(int eventId)
    {
        // Blokovat maz√°n√≠ v read-only re≈æimu
        if (_isReadOnly)
        {
            Console.WriteLine($"[RemoveEvent] BLOCKED - Read-only mode");
            _statusMessage = "‚ö†Ô∏è Hodnocen√≠ je ve stavu read-only. Nelze mazat ud√°losti.";
            _isError = true;
            StateHasChanged();
            await Task.Delay(2000);
            _statusMessage = string.Empty;
            StateHasChanged();
            return;
        }
        
        var eventToRemove = _scoringEvents.FirstOrDefault(e => e.Id == eventId);
        if (eventToRemove == null) return;
        
        _scoringEvents.Remove(eventToRemove);
        _currentScore -= eventToRemove.Points;
        
        // Odebrat z blockEventIds
        var key = $"{eventToRemove.X},{eventToRemove.Y}";
        if (_blockEventIds.ContainsKey(key))
        {
            _blockEventIds[key].Remove(eventId);
            if (_blockEventIds[key].Count == 0)
            {
                _blockEventIds.Remove(key);
                // Pokud byla vybran√° ud√°lost smaz√°na, zru≈°it v√Ωbƒõr
                if (_selectedEventId == eventId)
                {
                    _selectedBlockX = -1;
                    _selectedBlockY = -1;
                    _selectedEventId = -1;
                }
            }
        }
        
        StateHasChanged();
        
        // Auto-save po smaz√°n√≠
        await AutoSaveScore();
    }

    private string GetBlockClass(MapBlock? block)
    {
        if (block == null) return "empty";
        
        return block.Type switch
        {
            MapBlockType.Rock => "rock",
            MapBlockType.BlueCrystal => "blue-crystal",
            MapBlockType.YellowSulfur => "yellow-sulfur",
            _ => "empty"
        };
    }

    private string GetBlockIcon(MapBlockType type)
    {
        return type switch
        {
            MapBlockType.Rock => "ü™®",
            MapBlockType.BlueCrystal => "üíé",
            MapBlockType.YellowSulfur => "üü°",
            _ => ""
        };
    }

    private async Task MarkAsCompleted()
    {
        if (string.IsNullOrEmpty(_selectedTeamId) || _scoringEvents.Count == 0) return;
        
        try
        {
            _isSubmitting = true;
            _statusMessage = "Oznaƒçuji hodnocen√≠ jako dokonƒçen√©...";
            StateHasChanged();
            
            // Naƒç√≠st aktu√°ln√≠ hodnocen√≠
            var team = await TeamService.GetTeamByIdAsync(_selectedTeamId);
            if (team == null)
            {
                _statusMessage = "‚ùå T√Ωm nenalezen!";
                _isError = true;
                return;
            }
            
            var round = team.Rides.FirstOrDefault(r => r.RoundNumber == _currentRound!.RoundNumber);
            if (round == null)
            {
                _statusMessage = "‚ùå Kolo nenalezeno!";
                _isError = true;
                return;
            }
            
            var refereeId = UserSession.UserId ?? "referee1";
            if (round.RefereeScores.TryGetValue(refereeId, out var existingScore))
            {
                // Oznaƒçit jako submitted a resetovat rejection
                existingScore.IsSubmitted = true;
                existingScore.SubmittedAt = DateTime.UtcNow;
                existingScore.IsRejected = false;
                existingScore.RejectionReason = null;
                
                await ScoreService.SubmitRefereeScoreAsync(
                    _selectedTeamId, 
                    _currentRound!.RoundNumber, 
                    existingScore
                );
                
                // Notify admin via real-time service
                await ScoreNotificationService.NotifyRefereeScoreUpdated(
                    _selectedTeamId,
                    _currentRound!.RoundNumber,
                    refereeId
                );
                
                // P≈ôepnout do read-only re≈æimu
                _isReadOnly = true;
                _isAwaitingApproval = true;
                _wasRejected = false;
                
                _statusMessage = $"‚úÖ Hodnocen√≠ odesl√°no ke schv√°len√≠! T√Ωm z√≠skal {_currentScore} bod≈Ø.";
                _isError = false;
            }
            else
            {
                _statusMessage = "‚ùå Nejprve mus√≠te p≈ôidat ud√°losti!";
                _isError = true;
            }
        }
        catch (Exception ex)
        {
            _statusMessage = $"‚ùå Chyba: {ex.Message}";
            _isError = true;
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
            
            await Task.Delay(3000);
            _statusMessage = string.Empty;
            StateHasChanged();
        }
    }

    // Cleanup
    public void Dispose()
    {
        ScoreNotificationService.OnScoreApprovalChanged -= HandleScoreApprovalChanged;
    }
}
